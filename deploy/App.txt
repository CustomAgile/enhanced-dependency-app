<!DOCTYPE html>
<html>
<head>
    <title>enhanced-dependency-app-1.1.0</title>
    <!--  (c) 2019 Custom Agile.  All Rights Reserved. -->
    <!--  Build Date: Fri Aug 09 2019 11:19:19 GMT-0500 (Central Daylight Time) -->

    <script type="text/javascript">
        var APP_BUILD_DATE = "Fri Aug 09 2019 11:19:19 GMT-0500 (Central Daylight Time)";
        var CHECKSUM = 146997179778;
    </script>

    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * Overrides to allow a store load to the canceled which will abort loading
 * any subsequent pages and not invoke the load callback.
 */
Ext.override(Rally.data.PageableStore, {

    loadCanceled: false,

    cancelLoad: function() {
        this.loadCanceled = true;
    },

    load: function(options) {
        this.loadCanceled = false;
        this.callParent(arguments);
    },

    _shouldLoadMorePages: function(operation) {
        if (this.loadCanceled) {
            return false;
        }
        else {
            return this.callParent(arguments)
        }
    },

    _afterDoneLoadingAllPages: function(operation, success, callback, scope) {
        if (this.loadCanceled) {
            // Loading canceled. Don't send any events or invoke the callback
            this.resumeEvents();
            this.currentPage = 1;
            this.loading = false;
        }
        else {
            this.callParent(arguments);
        }
    }
});

Ext.define('Utils.AncestorPiAppFilter', {
    alias: 'plugin.UtilsAncestorPiAppFilter',
    mixins: [
        'Ext.AbstractPlugin',
        'Rally.Messageable'
    ],
    extend: 'Ext.Component',

    statics: {
        RENDER_AREA_ID: 'utils-ancestor-pi-app-filter',
        PANEL_RENDER_AREA_ID: 'multi-level-pi-app-filter-panel'
    },

    config: {
        /**
         * @cfg {Boolean}
         * The id of the component where the plugin will render its controls
         */
        renderAreaId: 'utils-ancestor-pi-app-filter',

        /**
         * @cfg {String}
         * The id of the component where the filter button will render itself
         */
        btnRenderAreaId: 'utils-ancestor-pi-app-filter',

        /**
         * @cfg {String}
         * The id of the component where the tabbed filter panel will render itself
         */
        panelRenderAreaId: 'multi-level-pi-app-filter-panel',

        /**
         * @cfg {Boolean}
         * Set to false to prevent app from displaying a multi-level PI filter
         */
        displayMultiLevelFilter: true,

        /**
         * @cfg {Boolean}
         * Set to true to indicate that this component is a publisher of events
         * to other apps using this plugin
         */
        publisher: false,

        /**
         * @cfg {Boolean}
         * Set to false to prevent the '-- None --' selection option if your app can't support
         * querying by a null ancestor (e.g. Lookback _ItemHierarchy)
         */
        allowNoEntry: true,

        /**
         * @cfg {Object}
         * Config applied to the app settings components
         */
        settingsConfig: {},

        /**
         * @cfg {Object}
         * Fetch list for PI Selector
         */
        defaultFetch: true,

        /**
         * @cfg {Array}
         * Whitelist array for inline filters
         */
        whiteListFields: [],

        /**
         * @cfg {Array}
         * Blacklist array for inline filters
         */
        blackListFields: [],

        /**
         * @cfg {Boolean}
         * Setting for inlineFilterButtonConfig
         */
        filterChildren: false,

        /**
         * @cfg {String}
         * Label of the Portfolio Item Type picker
         */
        ancestorLabel: 'With ancestor',

        /**
         * @cfg {Number}
         * Width of the Portfolio Item Type picker label
         */
        ancestorLabelWidth: 110,

        /**
         * @cfg {String}
         * Label of the Portfolio Item Type picker when shown with the ancestor filter
         */
        ownerLabel: 'and owned by',

        /**
         * @cfg {String}
         * Label of the Portfolio Item Type picker when shown by itself
         */
        ownerOnlyLabel: 'Owned by',

        /**
         * @cfg {Number}
         * Width of the Portfolio Item Type picker label
         */
        ownerLabelWidth: 110,


        /**
         * @cfg {Number}
         * Style of the Portfolio Item Type picker label
         */
        labelStyle: 'font-size: medium',

        /**
         * @cfg {Number}
         * Minimum width for single row layout
         */
        singleRowMinWidth: 840,

        /**
         * @cfg {Array}
         * Field list for multi-level filter panel
         */
        defaultFilterFields: ['ArtifactSearch', 'Owner'],

        /**
         * @cfg {Boolean}
         * Set to true to hide filters on load
         */
        filtersHidden: false,

        /**
         * @cfg {Boolean}
         * Set to true to hide advanced filters on load
         */
        advancedFilterCollapsed: false
    },
    filterControls: [],
    portfolioItemTypes: [],
    readyDeferred: null,
    piTypesDeferred: null,
    isSubscriber: false,
    changeSubscribers: [],
    publishedValue: {},

    constructor: function () {
        this.callParent(arguments);
        this._setupPubSub();
        Ext.tip.QuickTipManager.init();
    },

    initComponent: function () {
        this.callParent(arguments);
        this.addEvents('ready', 'select', 'change');
    },

    init: function (cmp) {
        this.cmp = cmp;

        this.cmp.on('resize', this._onCmpResize, this);

        // Get the area where plugin controls will render
        this.renderArea = this.cmp.down('#' + this.renderAreaId);

        // Get the area where filter button will render
        this.btnRenderArea = this.cmp.down('#' + this.btnRenderAreaId);

        // Get the area where tabbed filter panel will render
        this.panelRenderArea = this.cmp.down('#' + this.panelRenderAreaId);

        // Extend app settings fields
        var cmpGetSettingsFields = this.cmp.getSettingsFields;
        this.cmp.getSettingsFields = function () {
            return this._getSettingsFields(cmpGetSettingsFields.apply(cmp, arguments));
        }.bind(this);

        // Extend app default settings fields
        var appDefaults = this.cmp.defaultSettings;
        appDefaults['Utils.AncestorPiAppFilter.enableAncestorPiFilter2'] = false;
        appDefaults['Utils.AncestorPiAppFilter.projectScope'] = 'current';
        appDefaults['Utils.AncestorPiAppFilter.enableMultiLevelPiFilter'] = false;
        this.cmp.setDefaultSettings(appDefaults);

        Ext.override(Rally.ui.inlinefilter.InlineFilterPanel, {
            // We don't want chevrons in the tab panel
            _alignChevron: function () {
                if (this.chevron) { this.chevron.hide(); }
            }
        });

        // Add the control components then fire ready
        Promise.all([this._addAncestorControls(), this._addFilters()]).then(
            function () {
                this._setReady();
            }.bind(this),
            function (error) {
                Rally.ui.notify.Notifier.showError({ message: error });
                this._setReady();
            }
        );
    },

    notifySubscribers: function (changeType) {
        var data = this._getValue();
        data.changeType = changeType;
        _.each(this.changeSubscribers, function (subscriberName) {
            this.publish(subscriberName, data);
        }, this);
    },

    // Returns a filter that will ensure results are children of the
    // selected ancestor portfolio item. type is the TypeDefinition 
    // for the Portfolio Item level you wish to fetch.
    getAncestorFilterForType: function (type) {
        var filter;
        var modelName = type.toLowerCase();
        var currentValues = this._getValue();

        if (currentValues.piTypePath) {
            var selectedPiTypePath = currentValues.piTypePath;
            var selectedRecord = currentValues.isPiSelected;
            var selectedPi = currentValues.pi;
            var pisAbove = this._piTypeAncestors(modelName, selectedPiTypePath);
            if (selectedRecord && selectedPi !== null && pisAbove !== null) {
                var property = this._propertyPrefix(modelName, pisAbove);
                if (property) {
                    filter = new Rally.data.wsapi.Filter({
                        property: property,
                        value: selectedPi
                    });
                }
            }
            else if (selectedPi !== null) {
                // Filter out any items of this type because the ancestor pi filter is
                // enabled, but this type doesn't have any pi ancestor types
                filter = new Rally.data.wsapi.Filter({
                    property: 'ObjectID',
                    value: 0
                });
            }
        }

        return filter;
    },

    // Returns an array containing all of the filters applied in the
    // multi-level filter as well as the selected ancestor PI if one
    // is selected. type is the TypeDefinition for the Portfolio Item
    // level you wish to fetch.
    getAllFiltersForType: function (type) {
        let ancestorFilter = this.getAncestorFilterForType(type);
        let filters = ancestorFilter ? [ancestorFilter] : [];
        filters = filters.concat(this.getMultiLevelFiltersForType(type));

        return filters;
    },

    // Returns an array containing all of the filters applied in the
    // multi-level filter. type is the TypeDefinition for the Portfolio 
    // Item level you wish to fetch.
    getMultiLevelFiltersForType: function (type) {
        let filters = [];
        let modelName = type.toLowerCase();
        let multiLevelFilters = this.getMultiLevelFilters();

        _.each(multiLevelFilters, function (val, key) {
            if (modelName === key.toLowerCase()) {
                filters = filters.concat(val);
            }
            else {
                let pisAbove = this._piTypeAncestors(modelName, key);

                if (val.length && pisAbove !== null) {
                    let property = this._propertyPrefix(modelName, pisAbove);
                    if (property) {
                        _.each(val, function (filter) {
                            filters.push(new Rally.data.wsapi.Filter({
                                property: `${property}.${filter.property}`,
                                operator: filter.operator,
                                value: filter.value
                            }));
                        }.bind(this));
                    }
                }
            }
        }.bind(this));

        return filters;
    },

    // Returns an object containing all of the filters applied in the multi-level
    // filter. Keys are the type definition field and the resulting values are arrays
    // of filters
    getMultiLevelFilters: function () {
        if (this._isSubscriber()) {
            return this.publishedValue.filters;
        }

        var filters = {};
        _.each(this.filterControls, function (filterControl) {
            let typeName = (filterControl.inlineFilterButton.modelNames) || 'unknown';
            filters[typeName] = filterControl.inlineFilterButton.getFilters();
        });

        return filters;
    },

    getSelectedPiRecord: function () {
        return this._getValue().piRecord;
    },

    getIgnoreProjectScope: function () {
        return this._getValue().ignoreProjectScope;
    },

    // Returns an object of states for all of the inline filters
    // Used for getting and setting shared views
    getMultiLevelFilterStates: function () {
        if (this._isSubscriber()) {
            return this.publishedValue.filterStates;
        }

        var states = {};
        _.each(this.filterControls, function (filterControl) {
            let typeName = (filterControl.inlineFilterButton.modelNames) || 'unknown';
            states[typeName] = filterControl.inlineFilterButton.getState();
        });

        return states;
    },

    // Sets the states of the inline filters
    // Used when applying a shared view to the filters
    setMultiLevelFilterStates: function (states) {
        if (!this._isSubscriber()) {
            this.tabPanel.removeAll();
            for (let key in states) {
                if (states.hasOwnProperty(key)) {
                    for (let i = 0; i < this.filterControls.length; i++) {
                        let typeName = (this.filterControls[i].inlineFilterButton.modelNames) || 'unknown';
                        if (typeName === key) {
                            this.filterControls[i].inlineFilterButton.applyState(states[key]);
                        }
                    }
                }
            }
            setTimeout(function () { this.tabPanel.setActiveTab(0); }.bind(this), 1500);
        }
    },

    _setupPubSub: function () {
        if (this.publisher) {
            this.subscribe(this, 'registerChangeSubscriber', function (subscriberName) {
                // Register new unique subscribers
                if (!_.contains(this.changeSubscribers, subscriberName)) {
                    this.changeSubscribers.push(subscriberName);
                }
                this.publish(subscriberName, this._getValue());
            }, this);
            // Ask any existing subscribers to re-register
            this.publish('reRegisterChangeSubscriber');
        }
        else {
            this.subscriberEventName = Rally.getApp().getAppId() + this.$className;
            // Subscribe to a channel dedicated to this app
            this.subscribe(this, this.subscriberEventName, function (data) {
                if (this.intervalTimer) {
                    clearInterval(this.intervalTimer);
                    delete this.intervalTimer;
                }
                if (!this.isSubscriber) {
                    this.isSubscriber = true;
                    this._hideControlCmp();
                }
                this.publishedValue = data;

                // Default to an ancestor change event for backwards compatibility
                if (data.changeType === 'ancestor' || !data.changeType) {
                    this._onSelect();
                }
                else {
                    this._onChange();
                }
            }, this);
            // Attempt to register with a publisher (if one exists)
            this.publish('registerChangeSubscriber', this.subscriberEventName);
            this.intervalTimer = setInterval(function () {
                this.publish('registerChangeSubscriber', this.subscriberEventName);
            }.bind(this), 500);
            this.subscribe(this, 'reRegisterChangeSubscriber', function () {
                this.publish('registerChangeSubscriber', this.subscriberEventName);
            }, this);
        }
    },

    _getValue: function () {
        var result = {};
        if (this._isSubscriber()) {
            result = this.publishedValue || {};
        }
        else {
            if (this.piTypeSelector) {
                var selectedPiType = this.piTypeSelector.getRecord();
                if (selectedPiType && this.piSelector) {
                    var selectedPiTypePath = selectedPiType.get('TypePath');
                    var selectedRecord = this.piSelector.getRecord();
                    var selectedPi = this.piSelector.getValue();
                    _.merge(result, {
                        piTypePath: selectedPiTypePath,
                        isPiSelected: !!selectedRecord,
                        pi: selectedPi,
                        piRecord: selectedRecord
                    });
                }
            }
            result.ignoreProjectScope = this._ignoreProjectScope();
            result.filters = this.getMultiLevelFilters();
            result.filterStates = this.getMultiLevelFilterStates();
        }
        return result;
    },

    _setReady: function () {
        this.ready = true;
        this.fireEvent('ready', this);
    },

    // Ancestor filter dropdowns have been selected
    _onSelect: function () {
        if (this.ready) {
            this.fireEvent('select', this);
        }
    },

    // Multi-level filters have changed
    _onChange: function () {
        if (this.ready) {
            this.fireEvent('change', this.getMultiLevelFilters());
        }
    },

    _getSettingsFields: function (fields) {
        var currentSettings = Rally.getApp().getSettings();
        if (!currentSettings.hasOwnProperty('Utils.AncestorPiAppFilter.projectScope')) {
            currentSettings['Utils.AncestorPiAppFilter.projectScope'] = 'user';
        }
        var pluginSettingsFields = [{
            xtype: 'rallycheckboxfield',
            id: 'Utils.AncestorPiAppFilter.enableAncestorPiFilter2',
            name: 'Utils.AncestorPiAppFilter.enableAncestorPiFilter2',
            fieldLabel: 'Filter artifacts by ancestor portfolio item',
        }, {
            xtype: 'rallyportfolioitemtypecombobox',
            id: 'Utils.AncestorPiAppFilter.defaultPiType',
            name: 'Utils.AncestorPiAppFilter.defaultPiType',
            fieldLabel: "Default Portfolio Item type",
            valueField: 'TypePath',
            allowNoEntry: false,
            defaultSelectionPosition: 'last',
            // Disable the preference enabled combo box plugin so that this control value is app specific
            plugins: []
        },
        {
            xtype: 'radiogroup',
            fieldLabel: 'Show artifacts from',
            columns: 1,
            vertical: true,
            allowBlank: false,
            items: [{
                boxLabel: "User's current project(s).",
                name: 'Utils.AncestorPiAppFilter.projectScope',
                inputValue: 'current',
                checked: 'current' === currentSettings['Utils.AncestorPiAppFilter.projectScope']
            }, {
                boxLabel: "All projects in workspace.",
                name: 'Utils.AncestorPiAppFilter.projectScope',
                inputValue: 'workspace',
                checked: 'workspace' === currentSettings['Utils.AncestorPiAppFilter.projectScope']
            }, {
                boxLabel: 'User selectable (either current project(s) or all projects in workspace).',
                name: 'Utils.AncestorPiAppFilter.projectScope',
                inputValue: 'user',
                checked: 'user' === currentSettings['Utils.AncestorPiAppFilter.projectScope']
            },],
            listeners: {
                scope: this,
                change: function () {
                    return;
                }
            }
        },
        {
            xtype: 'rallycheckboxfield',
            id: 'Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter',
            name: 'Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter',
            fieldLabel: 'Enable multi-level portfolio item filter',
        }
        ];
        pluginSettingsFields = _.map(pluginSettingsFields, function (pluginSettingsField) {
            return _.merge(pluginSettingsField, this.settingsConfig);
        }, this);
        // apply any settings config to each field added by the plugin
        return pluginSettingsFields.concat(fields || []);
    },

    // Requires that app settings are available (e.g. from 'beforelaunch')
    _addAncestorControls: function () {
        var controlsLayout = {
            type: 'hbox',
            align: 'middle',
            defaultMargins: '0 10 0 0'
        };
        var ownerLabelWidth = this.ownerLabelWidth;
        if (this.cmp.getWidth() < this.singleRowMinWidth) {
            controlsLayout = 'vbox';
            ownerLabelWidth = this.ancestorLabelWidth;
        }
        var scopeControlByItself = false;
        if (this._showAncestorFilter() === false && this._showIgnoreProjectScopeControl() === true) {
            scopeControlByItself = true;
        }
        var controls = {
            xtype: 'container',
            id: 'controlsArea',
            overflowX: 'auto',
            layout: {
                type: 'hbox',
                align: 'top'
            },
            items: [{
                xtype: 'container',
                id: 'pubSubIndicatorArea',
                width: 25,
                padding: '6 5 0 0',
                hidden: !this.publisher && !this._isSubscriber(),
                items: [{
                    xtype: 'component',
                    id: 'publisherIndicator',
                    html: '<span class="icon-bullhorn icon-large"></span>',
                    hidden: !this.publisher
                },
                {
                    xtype: 'component',
                    id: 'subscriberIndicator',
                    html: '<span class="icon-link icon-large"></span>',
                    hidden: !this._isSubscriber()
                },
                ]
            }, {
                xtype: 'container',
                id: 'filtersArea',
                layout: controlsLayout,
                items: [{
                    xtype: 'container',
                    id: 'ancestorFilterArea',
                    layout: {
                        type: 'hbox',
                        align: 'middle'
                    },
                    items: [{
                        xtype: 'container',
                        id: 'piTypeArea',
                        layout: {
                            type: 'hbox',
                            align: 'middle'
                        },
                    },
                    {
                        xtype: 'container',
                        id: 'piSelectorArea',
                        layout: {
                            type: 'hbox',
                            align: 'middle',
                            padding: '0 0 0 5'
                        },
                    }
                    ]
                }, {
                    xtype: 'container',
                    id: 'scopeControlArea',
                    width: 250,
                    layout: {
                        type: 'hbox',
                        align: 'middle'
                    },
                    items: [{
                        xtype: 'rallycombobox',
                        id: 'ignoreScopeControl',
                        stateful: true,
                        stateId: this.cmp.getContext().getScopedStateId('Utils.AncestorPiAppFilter.ignoreProjectScopeControl'),
                        stateEvents: ['select'],
                        hidden: this._isSubscriber() || !this._showIgnoreProjectScopeControl(),
                        displayField: 'text',
                        valueField: 'value',
                        labelStyle: this.labelStyle,
                        labelWidth: ownerLabelWidth,
                        fieldLabel: scopeControlByItself ? this.ownerOnlyLabel : this.ownerLabel,
                        // Don't set initial value with this component or it will override the state
                        storeConfig: {
                            fields: ['text', 'value'],
                            data: [{
                                text: "Current Project(s)",
                                value: false
                            }, {
                                text: "Any Project",
                                value: true
                            }]
                        },
                        listeners: {
                            scope: this,
                            change: function () {
                                this._onSelect();
                            }
                        },
                    }]
                }]
            }]
        };

        if (this.renderArea) {
            // Without this, the components are clipped on narrow windows
            this.renderArea.setOverflowXY('auto', 'auto');
            this.renderArea.add(controls);
        }

        this._addTooltips();

        // Need to get pi types sorted by ordinal lowest to highest for the filter logic to work
        return new Promise(function (resolve) {
            Rally.data.util.PortfolioItemHelper.getPortfolioItemTypes().then({
                scope: this,
                success: function (data) {
                    this.portfolioItemTypes = data;

                    if (!this._isSubscriber() && this._showAncestorFilter()) {
                        // Now create the pi type selector
                        this._addPiTypeSelector().then(function () {
                            this._addPiSelector(this.piTypeSelector.getValue(), null).then(
                                function () {
                                    resolve();
                                }.bind(this)
                            );
                        }.bind(this));
                    }
                    else {
                        resolve();
                    }
                }
            });
        }.bind(this));
    },

    _addPiTypeSelector: function (initialValue) {
        return new Promise(function (resolve) {
            this.piTypeSelector = Ext.create('Rally.ui.combobox.PortfolioItemTypeComboBox', {
                xtype: 'rallyportfolioitemtypecombobox',
                id: 'Utils.AncestorPiAppFilter.piType',
                name: 'Utils.AncestorPiAppFilter.piType',
                width: 250,
                // Disable the preference enabled combo box plugin so that this control value is app specific
                plugins: [],
                stateful: true,
                stateId: this.cmp.getContext().getScopedStateId('Utils.AncestorPiAppFilter.piType'),
                stateEvents: ['select'],
                fieldLabel: this.ancestorLabel,
                labelWidth: this.ancestorLabelWidth,
                labelStyle: this.labelStyle,
                valueField: 'TypePath',
                value: initialValue || this._defaultPortfolioItemType(),
                allowNoEntry: false,
                defaultSelectionPosition: 'first',
                listeners: {
                    scope: this,
                    ready: function (combobox) {
                        // Unfortunately we cannot use the combobox store of PI types for our filter
                        // logic because it is sorted by ordinal from highest to lowest so that the
                        // picker options have a an order familiar to the user.

                        // Don't add the change listener until ready. This prevents us
                        // from adding and removing the pi selector multiple times during
                        // startup which causes a null ptr exception in that component
                        combobox.addListener({
                            scope: this,
                            change: this._onPiTypeChange
                        });
                        resolve();
                    }
                }
            });
            this.renderArea.down('#piTypeArea').add(this.piTypeSelector);
        }.bind(this));
    },

    _addTooltips: function () {
        Ext.tip.QuickTipManager.register({
            target: 'publisherIndicator',
            text: 'This app broadcasts filter settings to any enabled ancestor filtered apps (indicated with <span class="icon-link icon-large"></span>)',
            showDelay: 50,
            border: true
        });

        Ext.tip.QuickTipManager.register({
            target: 'subscriberIndicator',
            text: 'This app listens for filter settings from any enabled ancestor filter broadcast app (indicated with <span class="icon-bullhorn icon-large"></span>)',
            showDelay: 50,
            border: true
        });

        if (this._isSubscriber()) {
            Ext.tip.QuickTipManager.register({
                target: 'subscriberFilterIndicator',
                text: 'This app listens for filter settings from any enabled ancestor filter broadcast app (indicated with <span class="icon-bullhorn icon-large"></span>)',
                showDelay: 50,
                border: true
            });
        }
    },

    _onCmpResize: function (cmp, width) {
        var controlsLayout = {
            type: 'hbox',
            align: 'middle',
            defaultMargins: '0 10 0 0'
        };
        if (width < this.singleRowMinWidth) {
            controlsLayout = {
                type: 'vbox'
            };
        }
        var filtersArea = this.renderArea.down('#filtersArea');
        if (filtersArea) {
            var controlsArea = this.renderArea.down('#controlsArea');
            var filters = filtersArea.removeAll(false);
            var newFiltersArea = {
                xtype: 'container',
                id: 'filtersArea',
                layout: controlsLayout,
                items: filters,
                hidden: filtersArea.isHidden()
            };
            controlsArea.remove(filtersArea, false);
            controlsArea.add(newFiltersArea);
        }
    },

    _hideControlCmp: function () {
        if (this.renderArea) {
            this.renderArea.down('#pubSubIndicatorArea').show();
            this.renderArea.down('#subscriberIndicator').show();
            this.renderArea.down('#filtersArea').hide();
        }
    },

    _onPiTypeChange: function (piTypeSelector, newValue) {
        if (newValue) {
            let currentPi = this._getValue().pi;
            this._removePiSelector();
            this._addPiSelector(newValue).then(
                function () {
                    this._setReady();
                    // If an ancestor was selected it has now been cleared, so fire select event
                    if (currentPi) {
                        this._onSelect();
                    }
                }.bind(this)
            );
        }
    },

    _removePiSelector: function () {
        this.renderArea.down('#piSelectorArea').removeAll(true);
    },

    _addPiSelector: function (piType, initialValue) {
        return new Promise(function (resolve) {
            this.piSelector = Ext.create('Rally.ui.combobox.ArtifactSearchComboBox', {
                id: 'Utils.AncestorPiAppFilter.piSelector',
                width: 250,
                labelAlign: 'top',
                storeConfig: {
                    models: piType,
                    autoLoad: true,
                    fetch: this.defaultFetch,
                    context: {
                        project: null
                    }
                },
                queryDelay: 7000,
                autoSelectCurrentItem: false,
                stateful: true,
                stateId: this.cmp.getContext().getScopedStateId('Utils.AncestorPiAppFilter.piSelector'),
                stateEvents: ['select'],
                valueField: '_ref',
                allowClear: true,
                clearValue: null,
                allowNoEntry: this.allowNoEntry,
                noEntryValue: '',
                value: initialValue || '',
                // forceSelection: false,
                defaultSelectionPosition: null,
                listeners: {
                    scope: this,
                    select: function () {
                        this._onSelect();
                    },
                    ready: function () {
                        resolve();
                    }
                }
            });
            // Allow this combobox to save null state (which is default behavior of
            // stateful mixin, but for some reason was overridden in combobox)
            Ext.override(this.piSelector, {
                saveState: function () {
                    var me = this,
                        id = me.stateful && me.getStateId(),
                        hasListeners = me.hasListeners,
                        state;

                    if (id) {
                        state = me.getState() || {}; //pass along for custom interactions
                        if (!hasListeners.beforestatesave || me.fireEvent('beforestatesave', me, state) !== false) {
                            Ext.state.Manager.set(id, state);
                            if (hasListeners.statesave) {
                                me.fireEvent('statesave', me, state);
                            }
                        }
                    }
                }
            });
            this.renderArea.down('#piSelectorArea').add(this.piSelector);
        }.bind(this));
    },

    _setPiSelector: function (piType, pi) {
        return new Promise(function (resolve) {
            this.piTypeSelector.suspendEvents(false);
            this.piTypeSelector.setValue(piType);
            this._removePiSelector();
            this._addPiSelector(piType, pi).then(function () {
                this.piSelector.setValue(pi);
                this.piTypeSelector.resumeEvents();
                resolve();
            }.bind(this));
        }.bind(this));
    },

    _showAncestorFilter: function () {
        return this.cmp.getSetting('Utils.AncestorPiAppFilter.enableAncestorPiFilter2');
    },

    _showIgnoreProjectScopeControl: function () {
        return this.cmp.getSetting('Utils.AncestorPiAppFilter.projectScope') === 'user';
    },

    _ignoreProjectScope: function () {
        var result = false;
        if (this._showIgnoreProjectScopeControl()) {
            // If the control is shown, that values overrides the ignoreScope app setting
            result = this.renderArea.down('#ignoreScopeControl').getValue();
        }
        else if (this.cmp.getSetting('Utils.AncestorPiAppFilter.projectScope') === 'workspace') {
            result = true;
        }
        return result;
    },

    _isSubscriber: function () {
        return this.isSubscriber;
    },

    _defaultPortfolioItemType: function () {
        return this.cmp.getSetting('Utils.AncestorPiAppFilter.defaultPiType');
    },

    _propertyPrefix: function (typeName, piTypesAbove) {
        var property;
        if (typeName === 'hierarchicalrequirement' || typeName === 'userstory') {
            property = piTypesAbove[0].get('Name');
        }
        else if (typeName === 'defect') {
            property = 'Requirement.' + piTypesAbove[0].get('Name');
        }
        else if (Ext.String.startsWith(typeName, 'portfolioitem')) {
            property = 'Parent';
        }

        if (property) {
            // property already gets us to the lowest pi level above the current type
            // for each additional level, add a 'Parent' term, except for the last
            // type in the list which is the currently selected pi type ancestor
            _.forEach(piTypesAbove.slice(1), function () {
                property = property + '.Parent';
            }, this);
        }

        return property;
    },

    /**
     * Return a list of portfolio item types AT or below the selected pi type,
     * that are an ancestor of the given model, or null if there are no pi type
     * ancestors for the given model.
     */
    _piTypeAncestors: function (modelName, selectedPiTypePath) {
        var result = null;
        var selectedPiTypeIndex;
        var modelNamePiTypeIndex;

        if (_.contains(['hierarchicalrequirement', 'userstory', 'defect'], modelName)) {
            selectedPiTypeIndex = _.findIndex(this.portfolioItemTypes, function (piType) {
                return piType.get('TypePath').toLowerCase() === selectedPiTypePath.toLowerCase();
            });
            result = this.portfolioItemTypes.slice(0, selectedPiTypeIndex + 1);
        }
        else if (Ext.String.startsWith(modelName, 'portfolioitem')) {
            modelNamePiTypeIndex = _.findIndex(this.portfolioItemTypes, function (piType) {
                return piType.get('TypePath').toLowerCase() === modelName.toLowerCase();
            });
            selectedPiTypeIndex = _.findIndex(this.portfolioItemTypes, function (piType) {
                return piType.get('TypePath').toLowerCase() === selectedPiTypePath.toLowerCase();
            });

            if (modelNamePiTypeIndex < selectedPiTypeIndex) {
                // Don't include the current model pi in the list of ancestors
                // Include the selcted pi type ancestor
                result = this.portfolioItemTypes.slice(modelNamePiTypeIndex + 1, selectedPiTypeIndex + 1);
            }
        }

        return result;
    },

    /*
        Multi-Level Filter functions
    */
    _showMultiLevelFilter: function () {
        return this.cmp.getSetting('Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter');
    },

    _addFilters: function () {
        return new Promise(function (resolve, reject) {
            var promises = [];
            if (this._showMultiLevelFilter() && !this._isSubscriber()) {
                if (this.btnRenderArea) {
                    if (!this._isSubscriber()) {
                        this.showFiltersBtn = this.btnRenderArea.add(
                            {
                                xtype: 'rallybutton',
                                cls: this.filtersHidden ? 'secondary' : 'primary' + ' rly-small',
                                iconCls: 'icon-filter',
                                toolTipText: + this.filtersHidden ? 'Show' : 'Hide' + ' Filters',
                                handler: this._toggleFilters,
                                scope: this
                            }
                        );

                        Rally.data.util.PortfolioItemHelper.getPortfolioItemTypes().then({
                            scope: this,
                            success: function (piTypes) {
                                this.piTypes = piTypes.reverse();
                                var piTypePaths = _.map(piTypes, function (piType) {
                                    return piType.get('TypePath');
                                });

                                this.models = Rally.data.ModelFactory.getModels({
                                    types: piTypePaths,
                                    context: this.cmp.getContext(),
                                    scope: this,
                                    success: function (models) {

                                        this.tabPanel = this.panelRenderArea.add({
                                            xtype: 'tabpanel',
                                            width: '98%',
                                            cls: 'blue-tabs',
                                            minTabWidth: 100,
                                            plain: true,
                                            autoRender: true,
                                            hidden: this._isSubscriber(),
                                            items: []
                                        });

                                        this.filterControls = [];

                                        _.each(models, function (model, key) {
                                            promises.push(new Promise(function (newResolve) {
                                                var filterName = `inlineFilter${key}`;
                                                this.filterControls.push(Ext.create('Rally.ui.inlinefilter.InlineFilterControl', {
                                                    xtype: 'rallyinlinefiltercontrol',
                                                    name: filterName,
                                                    stateful: true,
                                                    stateId: this.cmp.getContext().getScopedStateId(`multi-${filterName}-control`),
                                                    itemId: filterName,
                                                    context: this.cmp.getContext(),
                                                    inlineFilterButtonConfig: {
                                                        stateful: true,
                                                        stateId: this.cmp.getContext().getScopedStateId(`multi-${filterName}`),
                                                        context: this.cmp.getContext(),
                                                        modelNames: key,
                                                        filterChildren: this.filterChildren,
                                                        inlineFilterPanelConfig: {
                                                            name: `${filterName}-panel`,
                                                            itemId: `${filterName}-panel`,
                                                            model: model,
                                                            padding: 5,
                                                            width: '98%',
                                                            context: this.cmp.getContext(),
                                                            quickFilterPanelConfig: {
                                                                defaultFields: this.defaultFilterFields,
                                                                addQuickFilterConfig: {
                                                                    whiteListFields: this.whiteListFields,
                                                                    blackListFields: this.blackListFields
                                                                }
                                                            },
                                                            advancedFilterPanelConfig: {
                                                                collapsed: this.advancedFilterCollapsed,
                                                                advancedFilterRowsConfig: {
                                                                    propertyFieldConfig: {
                                                                        blackListFields: this.blackListFields,
                                                                        whiteListFields: this.whiteListFields
                                                                    }
                                                                }
                                                            },
                                                        },
                                                        listeners: {
                                                            inlinefilterchange: this._onFilterChange,
                                                            inlinefilterready: function (panel) {
                                                                this._onFilterReady(panel);
                                                                newResolve();
                                                            },
                                                            scope: this
                                                        }
                                                    }
                                                }));
                                            }.bind(this)));
                                        }, this);

                                        Promise.all(promises).then(function () {

                                            if (!this._isSubscriber()) {
                                                this.clearAllButton = Ext.widget({
                                                    xtype: 'rallybutton',
                                                    itemId: 'clearAllButton',
                                                    cls: 'secondary rly-small clear-all-filters-button',
                                                    text: 'Clear All',
                                                    margin: '3 9 3 0',
                                                    hidden: !this._hasFilters(),
                                                    listeners: {
                                                        click: this._clearAllFilters,
                                                        scope: this
                                                    }
                                                });

                                                this.btnRenderArea.add(this.clearAllButton);
                                                this.tabPanel.setActiveTab(0);
                                                if (this.filtersHidden) {
                                                    this.tabPanel.hide();
                                                }

                                                // Without this, the components are clipped on narrow windows
                                                this.btnRenderArea.setOverflowXY('auto', 'auto');
                                            }
                                            resolve();
                                        }.bind(this));
                                    },
                                    failure: function () {
                                        reject('Failed to fetch models for multi-level filter');
                                    }
                                });
                            },
                            failure: function () {
                                reject('Failed to fetch portfolio item types for multi-level filter');
                            }
                        });
                    }
                    else {
                        this.btnRenderArea.add({
                            xtype: 'container',
                            id: 'filterSubIndicatorArea',
                            width: 25,
                            padding: '6 5 0 0',
                            items: [
                                {
                                    xtype: 'component',
                                    id: 'subscriberFilterIndicator',
                                    html: '<span class="icon-link icon-large"></span>'
                                }
                            ]
                        });
                    }
                } else {
                    reject('Unable to find button render area for multi-level filter');
                }
            }
            else {
                resolve();
            }
        }.bind(this));
    },

    _clearAllFilters: function () {
        this.suspendEvents(false);
        this.suspendLayouts();

        _.each(this.filterControls, function (filterControl) {
            filterControl.inlineFilterButton.clearAllFilters();
        });

        if (this.clearAllButton) {
            this.clearAllButton.hide();
        }

        this.resumeEvents();
        this.resumeLayouts(false);
        this.updateLayout();
        this.fireEvent('change', this.getMultiLevelFilters());
    },

    _hasFilters: function () {
        var filters = this.getMultiLevelFilters();
        var returnVal = false;

        _.each(filters, function (filter) {
            if (filter.length) {
                returnVal = true;
            }
        });

        return returnVal;
    },

    _onFilterReady: function (panel) {
        panel.expand();
        let filterCount = panel.quickFilterPanel.getFilters().length + panel.advancedFilterPanel.getFilters().length;
        let modelName = (panel.model && panel.model.elementName) || 'unknown';

        let tab = this.tabPanel.add({
            title: modelName + (filterCount ? ` (${filterCount})` : ''),
            html: '',
            itemId: `${modelName}-tab`,

        });

        tab.add({
            xtype: 'container',
            layout: 'hbox',
            items: [panel]
        });
    },

    _applyFilters: function () {
        this.suspendEvents(false);
        this.suspendLayouts();
        _.each(this.filterControls, function (filterControl) {
            filterControl.inlineFilterButton._applyFilters();
        });
        this.resumeEvents();
        this.resumeLayouts(false);
        this.updateLayout();
    },

    _onFilterChange: function () {
        if (this.clearAllButton) {
            if (this._hasFilters()) {
                this.clearAllButton.show();
            }
            else {
                this.clearAllButton.hide();
            }
        }

        _.each(this.filterControls, function (filterControl) {
            let typeName = (filterControl.inlineFilterButton.inlineFilterPanel.model.elementName) || 'unknown';
            this._setTabText(typeName, filterControl.inlineFilterButton.getFilters().length);
        }, this);

        if (this.ready) {
            this.fireEvent('change', this.getMultiLevelFilters());
        }
    },

    _setTabText: function (typeName, filterCount) {
        var titleText = filterCount ? `${typeName} (${filterCount})` : typeName;
        var tab = this.tabPanel.child(`#${typeName}-tab`);

        if (tab) { tab.setTitle(titleText); }
    },

    _toggleFilters: function (btn) {
        if (this.tabPanel.isHidden()) {
            this.tabPanel.show();
            btn.setToolTipText('Hide Filters');
            btn.addCls('primary');
            btn.removeCls('secondary');
        } else {
            this.tabPanel.hide();
            btn.setToolTipText('Show Filters');
            btn.addCls('secondary');
            btn.removeCls('primary');
        }
    }
});
/* globals Rally */
// Fix the PreliminaryEstimate renderer to sort by value
Rally.ui.renderer.GridEditorFactory.editorRenderers['PreliminaryEstimate'] = function(field) {
    return {
        xtype: 'rallyrecordcontexteditor',
        field: {
            xtype: 'rallycombobox',
            allowNoEntry: !field.required,
            editable: false,
            name: field.name,
            storeConfig: {
                autoLoad: true,
                model: field.name,
                remoteFilter: true,
                sorters: [{
                    property: "Value"
                }],
                listeners: {
                    load: function() {
                        return;
                    }
                }
            }
        }
    };
};

Ext.define('Utils.AncestorPiInlineFilter', {
    override: 'Rally.ui.inlinefilter.QuickFilterPanel',
    portfolioItemTypes: [],
    modelName: undefined,
    customFilterNamePrefix: "AncestorPiInlineFilter.",

    _hasPiAncestor: function(modelName) {
        return _.contains(['hierarchicalrequirement', 'userstory', 'defect'], modelName) || Ext.String.startsWith(modelName, 'portfolioitem');
    },

    _pisAbove: function(modelName) {
        var result = [];
        if (_.contains(['hierarchicalrequirement', 'userstory', 'defect'], modelName)) {
            result = this.portfolioItemTypes
        }
        else if (Ext.String.startsWith(modelName, 'portfolioitem')) {
            var startIndex = _.findIndex(this.portfolioItemTypes, function(piType) {
                return piType.get('TypePath').toLowerCase() === modelName;
            });
            if (startIndex >= 0 && startIndex < this.portfolioItemTypes.length - 1) {
                result = this.portfolioItemTypes.slice(startIndex + 1);
            }
        }
        return result;
    },

    initComponent: function() {
        if (!this.dataContext) {
            this.dataContext = Rally.getApp().getContext().getDataContext();
        }

        if (this.modelName) {
            this.modelName = this.modelName.toLowerCase();
        }
        var filterFactoryOverrides = {};
        var additionalFields = []
        if (this._hasPiAncestor(this.modelName)) {
            var pisAbove = this._pisAbove(this.modelName);
            _.each(pisAbove, function(piType) {
                var typePath = piType.get('TypePath');
                var customFilterName = this.customFilterNamePrefix + typePath;
                var displayName = 'Portfolio Item / ' + piType.get('Name');
                filterFactoryOverrides[customFilterName] = {
                    xtype: 'ancestorpisearchcombobox',
                    portfolioItemType: typePath, // The artifact type to search for
                    piTypesAbove: pisAbove, // List of portfolio item types
                    artifactTypeName: this.modelName, // The artifact type we are filtering
                    storeConfig: {
                        context: this.dataContext,
                        models: typePath,
                        autoLoad: true
                    },
                    allowNoEntry: true,
                    noEntryValue: null,
                    noEntryText: 'No ' + displayName,
                    emptyText: 'Search ' + displayName + 's...',
                    allowClear: false,
                    valueField: 'ObjectUUID', // Must use ObjectUUID to align with the state that is saved by inlinefilterbutton
                    forceSelection: false
                };
                additionalFields.push({
                    name: customFilterName,
                    displayName: displayName
                })
            }, this);

            // Add the additional fields to the quick filter config
            _.merge(this.addQuickFilterConfig, {
                additionalFields: additionalFields
            }, function(a, b) {
                if (_.isArray(a)) {
                    return _.uniq(a.concat(b), 'name') // Strip duplicates by name that can occur from state
                }
            });

            // Add the corresponding items to the FilterFieldFactory
            Ext.override(Rally.ui.inlinefilter.FilterFieldFactory, filterFactoryOverrides);
        }

        this.callParent(arguments);
    },

    _createFields: function() {
        // Strip out the custom filters from this.fields and this.initialFilters
        this.fields = _.filter(this.fields, function(field) {
            return this._filterInvalidAncestorFilters(field);
        }, this);
        this.initialFilters = _.filter(this.initialFilters, function(filter) {
            return this._filterInvalidAncestorFilters(filter.name);
        }, this);
        this.callParent(arguments);
    },

    /**
     * This will exclude any field restored from state that we didn't explicitly add into the Factory
     * for the current model type. This prevents changes in model types from trying to build an invalid filter
     * for that new model type.
     */
    _filterInvalidAncestorFilters: function(name) {
        return !Ext.String.startsWith(name, this.customFilterNamePrefix) || Rally.ui.inlinefilter.FilterFieldFactory.hasOwnProperty(name)
    }
});

Ext.define('Utils.AncestorPiSearchComboBox', {
    alias: 'widget.ancestorpisearchcombobox',
    extend: 'Rally.ui.combobox.ArtifactSearchComboBox',

    parentField: 'PortfolioItem.Parent.',

    artifactTypeName: undefined, // The name of the model that will be filtered
    piTypesAbove: [],
    statics: {
        UUID_REGEX: /([a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12})/
    },

    constructor: function(config) {
        if (config.value) {
            Ext.merge(config, {
                storeConfig: {
                    filters: Rally.data.wsapi.Filter.or([{
                            property: config.valueField, // Compensate for parent constructor assuming that filter value is OidFromRef
                            value: config.value
                        }
                        /*, {
                                                property: 'ObjectID',
                                                operator: '!=',
                                                value: 0
                                            }*/
                    ])
                }
            });
        }

        //this.callSuper(arguments);
        // Get super super method (skip the extended ArtifactSearchComboBox.constructor()
        return this.superclass.superclass['constructor'].apply(this, arguments);
    },

    initComponent: function() {
        this.on('change', function(cmp, newValue, oldValue) {
            if (newValue == "") {
                this.store.load({
                    filters: []
                })
            }
        }, this)
        return this.callParent(arguments);
    },

    setValue: function() {
        this.callParent(arguments);
    },

    getFilter: function() {

        var value = this.lastValue;
        var propertyPrefix = this.propertyPrefix();
        var filters = []
        // If the value is a UUID, then use it, otherwise ignore values the user might be typing in
        if (value && this.statics().UUID_REGEX.test(value)) {
            filters.push({
                property: propertyPrefix + ".ObjectUUID",
                value: value
            });
        }
        else {
            filters.push({
                property: propertyPrefix,
                value: null
            });
        }
        return Rally.data.wsapi.Filter.or(filters);
    },

    propertyPrefix: function() {
        var property;
        // Get the path between the selected artifact and the lowest level PI above it
        if (this.artifactTypeName === 'hierarchicalrequirement' || this.artifactTypeName === 'userstory') {
            property = this.piTypesAbove[0].get('Name');
        }
        else if (this.artifactTypeName === 'defect') {
            property = 'Requirement.' + this.piTypesAbove[0].get('Name');
        }
        else if (Ext.String.startsWith(this.artifactTypeName, 'portfolioitem')) {
            property = 'Parent';
        }

        if (property) {
            // Now add .Parent for every PI level above the lowest until we get to the
            // desired PI type
            _.forEach(this.piTypesAbove, function(piType) {
                if (piType.get('TypePath').toLowerCase() == this.portfolioItemType.toLowerCase()) {
                    return false;
                }
                else {
                    property = property + '.Parent'
                }
            }, this);
        }

        return property;
    }
});

/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",
    
    defaults: { padding: 5, margin: 5 },

    closable: true,
     
    draggable: true,

    autoShow: true,
   
    width: 350,
    
    informationalConfig: null,
    
    items: [{xtype:'container', itemId:'information' }],
    
    initComponent: function() {
        var id = Ext.id(this);
        this.title =  "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },
    
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/var BUILDER  = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
       
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
   
        return chk;
    },
    
    _checkChecksum: function(container) {
        var deferred = Ext.create('Deft.Deferred');
        var me = this;
        
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    var stored_checksum = me._generateChecksum(text);
                    if ( CHECKSUM !== stored_checksum ) {
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });
        
        return deferred.promise;
    },
    
    _addToContainer: function(container){
        var config = Ext.apply({
            xtype:'container',
            height: 200,
            overflowY: true
        }, this.informationalConfig);
        
        container.add(config);
    },
    
    afterRender: function() {
        var app = Rally.getApp();
        
        if ( !Ext.isEmpty( this.informationalConfig ) ) {
            var container = this.down('#information');
            this._addToContainer(container);
            
        }
        
        if (! app.isExternal() ) {
            this._checkChecksum(app).then({
                scope: this,
                success: function(result){
                    if ( !result ) {
                        this.addDocked({
                            xtype:'container',
                            cls: 'build-info',
                            dock: 'bottom',
                            padding: 2,
                            html:'<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                },
                failure: function(msg){
                    console.log("oops:",msg);
                }
            });
        } else {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html:'... Running externally'
            });
        }
        this.callParent(arguments);
    },
    
    beforeRender: function() {
        var me = this;
        this.callParent(arguments);

        if (this.informationHtml) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: this.informationHtml,
                doc: 'top'
            });
        }
        
        this.addDocked({
            xtype:'container',
            cls: 'build-info',
            padding: 2,
            dock:'bottom',
            html:"This app was created by the CA AC Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            var build_html = Ext.String.format("Built on: {0} <br/>Built by: {1}",
                APP_BUILD_DATE,
                BUILDER);
                
            if ( STORY ) {
                build_html = build_html + "<br/>Source story: " + STORY;
            }
                
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html: build_html
            });
        }
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('CArABU.technicalservices.FieldPicker', {
    alias: 'widget.fieldpickerbutton',
    extend:'Rally.ui.Button',
    requires: [
        'Rally.ui.popover.Popover',
        'Rally.ui.Button',
        'Rally.ui.picker.FieldPicker',
        'Ext.state.Manager'
    ],
    toolTipConfig: {
        html: 'Show Columns',
        anchor: 'top'
    },
    iconCls: 'icon-add-column',

    cls: 'field-picker-btn secondary rly-small',

    alwaysSelectedValues: ['FormattedID', 'Name'], // DragAndDropRank gets added in init if Drag and Drop is enabled for the workspace in the component's context

    fieldBlackList: ['Milestones','Tags','Defects','Attachments'],

    fieldPickerConfig: {},

    buttonConfig: {},

    modelNames: ['HierarchicalRequirement'],

    rankingEnabled: false,

    margin: '3 9 0 0',

    //This does not show the Rank column

    constructor: function (config) {
        this.config = _.merge({}, this.config || {}, config || {});
        this.callParent([config]);
    },

    initComponent: function() {

        if (this.models){
            this.on('click', this._createPopover, this);
            this.callParent(arguments);
            return;
        }

        if (this.context && this.modelNames && this.modelNames.length > 0){
            Rally.data.ModelFactory.getModels({
                types: this.modelNames,
                context: this.context,
                success: function(models){
                    this.models = models;
                    this.on('click', this._createPopover, this);
                },
                failure: function(failedParam){
                  this._setNoFieldPicker("There was an error retrieving models for the CArABU field picker.");
                },
                scope: this
            });

        } else {
            var msg = "Please update the CA.technicalservices.FieldPicker configuration with modelNames and context";
            this._setNoFieldPicker(msg);
        }
        this.callParent(arguments);
    },
    _setNoFieldPicker: function(msg){
      this.iconCls = 'icon-none';

      this.toolTipConfig= {
          html: '<div style="color:red;">' + msg + '</div>'
      };
      this.on('click', function(){ Rally.ui.notify.Notifier.showError({message: msg}); });
    },
    getFields: function(){
        return this._fields || this.alwaysSelectedValues;
    },

    _getPickerConfig: function() {
        var pickerConfig;
        pickerConfig = _.extend({
            value: this._fields,
            fieldBlackList: this.fieldBlackList,
            alwaysSelectedValues: this.alwaysSelectedValues,
            context: this.context
        }, this.fieldPickerConfig);

        return pickerConfig;
    },

    _createPopover: function(btn) {
        var popoverTarget = btn.getEl();

        this.popover = Ext.create('Rally.ui.popover.Popover', {
            target: popoverTarget,
            placement: ['bottom', 'left', 'top', 'right'],
            cls: 'field-picker-popover',
            toFront: Ext.emptyFn,
            buttonAlign: 'center',
            title: this.getTitle(),
            listeners: {
                destroy: function () {
                    this.popover = null;
                },
                scope: this
            },
            buttons: [
                {
                    xtype: "rallybutton",
                    text: 'Apply',
                    cls: 'field-picker-apply-btn primary rly-small',
                    listeners: {
                        click: function() {
                            this._onApply(this.popover);
                        },
                        scope: this
                    }
                },
                {
                    xtype: "rallybutton",
                    text: 'Cancel',
                    cls: 'field-picker-cancel-btn secondary dark rly-small',
                    listeners: {
                        click: function() {
                            this.popover.close();
                        },
                        scope: this
                    }
                }
            ],
            items: [
                _.extend({
                    xtype: 'rallyfieldpicker',
                    cls: 'field-picker',
                    itemId: 'fieldpicker',
                    modelTypes: this._getModelTypes(),
                    alwaysExpanded: true,
                    width: 200,
                    emptyText: 'Search',
                    selectedTextLabel: 'Selected',
                    availableTextLabel: 'Available',
                    listeners: {
                        specialkey: function(field, e) {
                            if (e.getKey() === e.ESC) {
                                this.popover.close();
                            }
                        },
                        scope: this
                    }
                }, this._getPickerConfig())
            ]
        });
    },

    _getModelTypes: function() {
        return _.pluck(this._getModels(), 'typePath');
    },
    getModel: function(){
       var models = this._getModels();
       if (models.length > 0){
         return models[0];
       }
       return null;
    },
    getFieldObjects: function(){
      var fields = this.getFields(),
         models = this._getModels();

      if (models.length > 0){
         return Ext.Array.map(fields, function(f){ return models[0].getField(f); });
      }
      return [];
    },
    _getModels: function() {
        return _.reduce(this.models, function(accum, model) {
            if (model.typePath === 'artifact') {
                accum = accum.concat(model.getArtifactComponentModels());
            } else {
                accum.push(model);
            }
            return accum;
        }, []);
    },

    getTitle: function () {
        return 'Show Columns';
    },

    /**
     * Update the fields displayed. In grid mode this will be the columns displayed. In board mode it will be
     * the fields on the cards
     *
     * @param {String[]|Object[]} fields A list of field names to display
     * @param {Boolean} true to suspend store load if it will be triggered elsewhere
     */
    updateFields: function (fields, suspendLoad) {
        this._fields = fields;
        if (this.popover && this.popover.down('rallyfieldpicker')) {
            this.popover.down('rallyfieldpicker').setValue(fields.join(','));
        }
        this.saveState();
    },
    getState: function(){
        return {
            fields: this._fields
        };
    },
    applyState: function(state){
        if (state){
            this._fields = state.fields;
        }
    },
    _onApply: function(popover) {
        var fieldPicker = popover.down('rallyfieldpicker'),
            fields = _.map(fieldPicker.getValue(), function (field) {
                return field.get('name');
            });

        this.updateFields(fields);
        popover.close();

        this.fireEvent('fieldsupdated', fields);
    }
});

Ext.define('CArABU.technicalservices.FileUtility',{
  singleton: true,
  saveCSVToFile:function(csv,file_name,type_object){
      if (type_object === undefined){
          type_object = {type:'text/csv;charset=utf-8'};
      }
      this.saveAs(csv,file_name, type_object);
  },
  saveAs: function(textToWrite, fileName)
  {
      if (Ext.isIE9m){
          Rally.ui.notify.Notifier.showWarning({message: "Export is not supported for IE9 and below."});
          return;
      }

      var textFileAsBlob = null;
      try {
          textFileAsBlob = new Blob([textToWrite], {type:'text/plain'});
      }
      catch(e){
          window.BlobBuilder = window.BlobBuilder ||
              window.WebKitBlobBuilder ||
              window.MozBlobBuilder ||
              window.MSBlobBuilder;
          if (window.BlobBuilder && e.name == 'TypeError'){
              bb = new BlobBuilder();
              bb.append([textToWrite]);
              textFileAsBlob = bb.getBlob("text/plain");
          }
      }

      if (!textFileAsBlob){
          Rally.ui.notify.Notifier.showWarning({message: "Export is not supported for this browser."});
          return;
      }

      var fileNameToSaveAs = fileName;

      if (Ext.isIE10p){
          window.navigator.msSaveOrOpenBlob(textFileAsBlob,fileNameToSaveAs); // Now the user will have the option of clicking the Save button and the Open button.
          return;
      }

      var url = this.createObjectURL(textFileAsBlob);

      if (url){
          var downloadLink = document.createElement("a");
          if ("download" in downloadLink){
              downloadLink.download = fileNameToSaveAs;
          } else {
              //Open the file in a new tab
              downloadLink.target = "_blank";
          }

          downloadLink.innerHTML = "Download File";
          downloadLink.href = url;
          if (!Ext.isChrome){
              // Firefox requires the link to be added to the DOM
              // before it can be clicked.
              downloadLink.onclick = this.destroyClickedElement;
              downloadLink.style.display = "none";
              document.body.appendChild(downloadLink);
          }
          downloadLink.click();
      } else {
          Rally.ui.notify.Notifier.showError({message: "Export is not supported "});
      }

  },
  createObjectURL: function ( file ) {
      if ( window.webkitURL ) {
          return window.webkitURL.createObjectURL( file );
      } else if ( window.URL && window.URL.createObjectURL ) {
          return window.URL.createObjectURL( file );
      } else {
          return null;
      }
  },
  destroyClickedElement: function(event)
  {
      document.body.removeChild(event.target);
  }

});

Ext.define('CArABU.technicalservices.ModelBuilder',{
    singleton: true,

    build: function(modelType, newModelName) {
        var deferred = Ext.create('Deft.Deferred');

        Rally.data.ModelFactory.getModel({
            type: modelType,
            success: function(model) {

                var default_fields = [{
                  name: '__predecessors'
                }];

                var new_model = Ext.define(newModelName, {
                    extend: model,
                    logger: new Rally.technicalservices.Logger(),
                    fields: default_fields,
                    loadPredecessors: function(predecessorFetch) {
                       //we can do stuff to the model here
                       var deferred = Ext.create('Deft.Deferred');
                       this.getCollection('Predecessors',{
                           fetch: predecessorFetch,
                           context: {project: null}
                       }).load({
                         callback: function(records, operation){
                           var predecessors = Ext.Array.map(records, function(r){ return r.getData(); });
                           this.set('__predecessors', predecessors);
                           deferred.resolve(this);
                         },
                         scope: this
                       });
                       return deferred.promise;
                     }
                });
                deferred.resolve(new_model);
            }
        });
        return deferred;
    }
});

Ext.define("enhanced-dependency-app", {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),

    items: [{
        id: Utils.AncestorPiAppFilter.RENDER_AREA_ID,
        xtype: 'container',
        layout: {
            type: 'hbox',
            align: 'middle',
            defaultMargins: '0 10 10 0',
        }
    }, {
        id: Utils.AncestorPiAppFilter.PANEL_RENDER_AREA_ID,
        xtype: 'container',
        layout: {
            type: 'hbox',
            align: 'middle',
            defaultMargins: '0 10 10 0',
        }
    }, {
        id: 'grid-area',
        xtype: 'container',
        flex: 1,
        type: 'vbox',
        align: 'stretch'
    }],

    piLevel0Name: 'Feature',

    launch: function () {
        Rally.data.wsapi.Proxy.superclass.timeout = 240000;

        // Begin loading pi types while waiting for ready event
        var piTypesPromise = Rally.data.util.PortfolioItemHelper.getPortfolioItemTypes();
        this.on('ready', function () {
            this.ancestorFilterPlugin = Ext.create('Utils.AncestorPiAppFilter', {
                ptype: 'UtilsAncestorPiAppFilter',
                pluginId: 'ancestorFilterPlugin',
                filtersHidden: false,
                settingsConfig: {
                    labelWidth: 150
                },
                listeners: {
                    scope: this,
                    ready: function (plugin) {
                        piTypesPromise.then({
                            scope: this,
                            success: function (piTypes) {
                                this.portfolioItemTypes = piTypes;
                                this.piLevel0Name = piTypes[0].get('Name');
                                this._addComponents();
                                plugin.addListener({
                                    scope: this,
                                    select: this._update,
                                    change: this._update
                                });
                                this._update();
                            }
                        });
                    },
                }
            });
            this.addPlugin(this.ancestorFilterPlugin);
        }, this);
    },
    _addComponents: function () {
        var gridArea = this.down('#grid-area');
        gridArea.removeAll();

        var selectorBox = gridArea.add({
            xtype: 'container',
            layout: 'hbox'
        });

        var filterBox = gridArea.add({
            xtype: 'container',
            itemId: 'filter_box',
            flex: 1
        });


        gridArea.add({
            xtype: 'container',
            itemId: 'display_box'
        });

        if (this._getSelectorType()) {
            selectorBox.add({
                xtype: this._getSelectorType(),
                fieldLabel: 'Release',
                labelAlign: 'right',
                margin: '10 5 10 5',
                labelWidth: 75,
                width: 400,
                storeConfig: {
                    context: { projectScopeDown: false }
                },
                listeners: {
                    scope: this,
                    change: this._update
                }
            });

        }

        var fp = selectorBox.add({
            xtype: 'fieldpickerbutton',
            modelNames: ['HierarchicalRequirement'],
            context: this.getContext(),
            margin: '10 5 10 5',
            stateful: true,
            stateId: 'grid-columns',
            _fields: [this.piLevel0Name, 'FormattedID', 'Name', 'ScheduleState', 'Iteration']
        });
        fp.on('fieldsupdated', this._update, this);

        selectorBox.add({
            xtype: 'rallybutton',
            itemId: 'btn-export',
            iconCls: 'icon-export',
            cls: 'rly-small secondary',
            margin: '10 5 10 5',
            align: 'right',
            scope: this,
            handler: this._exportData
        });
    },
    _getSelectorType: function () {
        if (this._hasMilestoneScope() || this._hasReleaseScope()) {
            return null;
        }
        return 'rallyreleasecombobox';
    },
    _getTimeBoxRecord: function () {
        if (this.down('rallymilestonecombobox') && this.down('rallymilestonecombobox').getRecord()) {
            return this.down('rallymilestonecombobox').getRecord();
        }
        if (this.down('rallyreleasecombobox') && this.down('rallyreleasecombobox').getRecord()) {
            return this.down('rallyreleasecombobox').getRecord();
        }

        this.logger.log('_getTimeboxRecord', this.getContext().getTimeboxScope());

        if (this._hasMilestoneScope() || this._hasReleaseScope()) {
            return this.getContext().getTimeboxScope().getRecord() || null;
        }
        return null;
    },
    _hasTimeboxScope: function (type) {
        this.logger.log('_hasTimeboxScope', this.getContext().getTimeboxScope());
        if (this.getContext().getTimeboxScope() && this.getContext().getTimeboxScope().type.toLowerCase() === type.toLowerCase()) {
            return true;
        }
        return false;
    },
    _hasMilestoneScope: function () {
        return this._hasTimeboxScope('milestone');
    },
    _hasReleaseScope: function () {
        return this._hasTimeboxScope('release');
    },
    onTimeboxScopeChange: function (timeboxScope) {
        if (timeboxScope && (timeboxScope.getType().toLowerCase() === 'milestone' || timeboxScope.getType() === 'release')) {
            this.callParent(arguments);
            this._update();
        }
    },
    _exportData: function () {
        if (!this.down('#grid-dependencies')) {
            return;
        }

        var columnCfgs = this._getColumnCfgs(),
            headers = [];
        Ext.Array.each(columnCfgs, function (c) {
            headers.push(c.text);
        });
        var csv = [headers.join(',')];

        var store = this.down('#grid-dependencies').getStore();
        store.each(function (r) {
            var row = [];
            Ext.Array.each(columnCfgs, function (c) {
                var val = r.get(c.dataIndex);
                if (Ext.isObject(val)) {
                    if (val.FormattedID) {
                        val = Ext.String.format("{0}: {1}", val.FormattedID, val.Name);
                    }
                    else {
                        val = val.Name || val._refObjectName;
                    }
                }
                row.push(val);
            });
            csv.push(row.join(','));
        });

        var file_name = Ext.String.format('dependencies-{0}.csv', Rally.util.DateTime.format(new Date(), 'Y-m-d-h-i-s'));
        CArABU.technicalservices.FileUtility.saveCSVToFile(csv.join('\r\n'), file_name);
    },
    _getTimeboxFilter: function () {
        var tbRecord = this._getTimeBoxRecord();
        this.logger.log('_getTimeBoxRecord', tbRecord);

        var filters = null;

        if (tbRecord && tbRecord.get('_type') === 'milestone') {
            filters = [{
                property: 'Milestones',
                value: tbRecord.get('_ref')
            }, {
                property: this.piLevel0Name + '.Milestones',
                value: tbRecord.get('_ref')
            }];
            filters = Rally.data.wsapi.Filter.or(filters);
        }

        if (tbRecord && tbRecord.get('_type') === 'release') {
            filters = [{
                property: 'Release.Name',
                value: tbRecord.get('Name')
            }, {
                property: this.piLevel0Name + '.Release.Name',
                value: tbRecord.get('Name')
            }];
            filters = Rally.data.wsapi.Filter.or(filters);
        }

        return filters;

    },
    _update: function () {
        this.setLoading(true);
        // If there is a current chart store, force it to stop loading pages
        // Note that recreating the grid will then create a new chart store with
        // the same store ID.
        var storyStore = Ext.getStore('storyStore');
        if (storyStore) {
            storyStore.cancelLoad();
        }
        var displayBox = this.down('#display_box');
        displayBox.removeAll();

        if (!this._getTimeboxFilter()) {
            displayBox.add({
                xtype: 'container',
                html: '<div class="selector-msg"><span style="color:#888888;">Please select a valid Timebox.</span></div>'
            });
            return;
        }

        CArABU.technicalservices.ModelBuilder.build('HierarchicalRequirement', 'StoryPredecessor', this._getAdditionalPredecessorFields()).then({
            success: this._fetchData,
            failure: this._showErrorNotification,
            scope: this
        });
    },
    _getFetch: function (isPredecessorFetch) {
        var fields = this.down('fieldpickerbutton').getFields();
        this.logger.log('_getFetch', fields);
        return fields;
    },
    _getAdditionalPredecessorFields: function () {
        var fields = this.down('fieldpickerbutton').getFieldObjects(),
            hiddenFields = ['Predecessors', 'ObjectID'];

        this.logger.log('_getAdditionalPredecessorFields', fields);

        var additionalFields = [];
        Ext.Array.each(fields, function (f) {
            var allowedValues = null;
            if (!Ext.Array.contains(hiddenFields, f.name)) {
                if (f.name === 'ScheduleState') {
                    allowedValues = f.getAllowedValueStore();
                }
                var nf = {
                    name: 'P' + f.name,
                    displayName: 'Predecessor ' + f.displayName
                };
                if (allowedValues) {
                    nf.getAllowedValueStore = function () {
                        return allowedValues;
                    };
                }
                additionalFields.push(nf);
            }
        });
        this.logger.log('_getAdditionalPredecessorFields', additionalFields);
        return additionalFields;
    },
    _fetchData: function (model) {
        var filters = Ext.create('Rally.data.wsapi.Filter', {
            property: 'Predecessors.ObjectID',
            operator: '!=',
            value: null
        }),
            timeboxFilter = this._getTimeboxFilter();

        filters = filters.and(timeboxFilter);
        var ancestorFilters = this.ancestorFilterPlugin.getAllFiltersForType('HierarchicalRequirement');
        if (ancestorFilters) {
            for (var i = 0; i < ancestorFilters.length; i++) {
                filters = filters.and(ancestorFilters[i]);
            }
        }

        this.logger.log('_fetchData filters', filters, filters.toString());

        var dataContext = this.getContext().getDataContext();
        if (this.searchAllProjects()) {
            dataContext.project = null;
        }
        Ext.create('Rally.data.wsapi.Store', {
            storeId: 'storyStore',
            model: model,
            fetch: this._getFetch(),
            filters: filters,
            limit: this.searchAllProjects() ? 2000 : 'Infinity',
            context: dataContext
        }).load({
            callback: this._loadPredecessors,
            scope: this
        });

    },
    _getColumnCfgs: function () {
        var fields = this.down('fieldpickerbutton').getFieldObjects();
        var cols = [];

        Ext.Array.each(fields, function (f) {
            var field_name = '__p' + f.name;

            var field = {
                dataIndex: field_name,
                text: 'Predecessor ' + f.displayName,
                tdCls: 'tspredecessor'
            };
            if (f.name === 'Name') {
                field.flex = 1;
            }
            var template = Rally.ui.renderer.RendererFactory.getRenderTemplate(f);
            field.renderer = function (v, m, r) {
                return template.apply(r.get('__predecessor'));
            };
            field.sortable = false;
            cols.push(field);
        });

        Ext.Array.each(fields, function (f) {
            var field = {
                dataIndex: f.name,
                text: f.displayName
            };
            if (f.name === 'Name') {
                field.flex = 1;
            }
            var template = Rally.ui.renderer.RendererFactory.getRenderTemplate(f);
            field.renderer = function (v, m, r) {
                return template.apply(r.getData());
            };
            field.doSort = function (state) {
                var ds = this.up('rallygrid').getStore();
                var field = this.getSortParam();
                console.log('ds', ds.sorters);
                ds.sort({
                    property: field,
                    direction: state,
                    sorterFn: function (v1, v2) {
                        v1 = v1.get(field);
                        v2 = v2.get(field);
                        if (Ext.isObject(v1)) {
                            v1 = v1._refObjectName || v1.Name || v1.FormattedID || v1;
                        }
                        if (Ext.isObject(v2)) {
                            v2 = v2._refObjectName || v2.Name || v2.FormattedID || v2;
                        }
                        // transform v1 and v2 here
                        if (!v1) {
                            return -1;
                        }
                        if (!v2) {
                            return 1;
                        }
                        return v1 > v2 ? 1 : (v1 < v2 ? -1 : 0);
                    }
                });
            };

            cols.push(field);
        });

        this.logger.log('_getColumnCfgs', cols);
        return cols;
    },
    _objectSort: function (state) {

    },
    _loadPredecessors: function (records, operation) {
        this.logger.log('_loadPredecessors', records, operation);
        var predecessorFetch = this._getFetch(),
            promises = [],
            objectIDs = [];
        Ext.Array.each(records, function (r) {
            if (!Ext.Array.contains(objectIDs, r.get('ObjectID'))) {
                promises.push(r.loadPredecessors(predecessorFetch));
                objectIDs.push(r.get('ObjectID')); //this is a hack to work around the issue where multiple records are being returned from store, but not api (not sure why)
            }
        });

        if (promises.length === 0) {
            this._buildCustomGrid([]);
        }
        else {
            Deft.Promise.all(promises).then({
                success: this._buildCustomGrid,
                failure: this._showErrorNotification,
                scope: this
            });
        }

    },

    _buildCustomGrid: function (results) {
        this.logger.log('_buildCustomGrid', results);
        var data = [],
            fields = this.down('fieldpickerbutton').getFields();

        Ext.Array.each(results, function (r) {
            var predecessors = r.get('__predecessors');
            Ext.Array.each(predecessors, function (p) {
                row = r.getData();
                row.__predecessor = p;
                Ext.Array.each(fields, function (f) {
                    row['__p' + f] = p[f];
                });
                data.push(row);
            });
        });

        var storeFields = fields.concat(Ext.Array.map(fields, function (f) {
            return '__p' + f;
        })).concat(['__predecessor']);
        storeFields.unshift('_ref');
        var store = Ext.create('Rally.data.custom.Store', {
            fields: storeFields,
            data: data,
            pageSize: Math.max(data.length, 200),
            remoteSort: false
        });

        if (this.down('#grid-dependencies')) {
            this.down('#grid-dependencies').destroy();
        }

        this.down('#display_box').add({
            xtype: 'rallygrid',
            itemId: 'grid-dependencies',
            showRowActionsColumn: false,
            showPagingToolbar: false,
            store: store,
            columnCfgs: this._getColumnCfgs(),
            viewConfig: {
                stripeRows: false
            },
            autoScroll: true
        });
        this.setLoading(false);
    },
    _showErrorNotification: function (error) {
        this.setLoading(false);
        this.logger.log('_showErrorNotification', error);
        Rally.ui.notify.Notifier.showError({ message: error });
    },

    setLoading: function (loading) {
        var displayBox = this.down('#display_box');
        displayBox.setLoading(loading);
    },

    getOptions: function () {
        return [{
            text: 'About...',
            handler: this._launchInfo,
            scope: this
        }];
    },

    _launchInfo: function () {
        if (this.about_dialog) { this.about_dialog.destroy(); }
        this.about_dialog = Ext.create('Rally.technicalservices.InfoLink', {});
    },

    isExternal: function () {
        return typeof (this.getAppId()) == 'undefined';
    },

    searchAllProjects: function () {
        return this.ancestorFilterPlugin.getIgnoreProjectScope();
    },

    /**
     * Must return a non-zero list of settings to allow the ancestorFilter plugin to
     * insert its settings. The SDK decides if an app should have a settings menu option
     * *before* initializing app plugins created in app.launch()
     */
    getSettingsFields: function () {
        return [{
            xtype: 'container'
        }];
    }

});


               Rally.launchApp('enhanced-dependency-app', {
                   name: 'enhanced-dependency-app'
               });
        });
    </script>

    <style type="text/css">

.blue-tabs .x-tab-bar .x-tab-default {
    background-color: white;
    border-radius: 4px 4px 0 0;
  }
  
  .blue-tabs .x-tab-bar .x-tab-default .x-tab-inner {
    color: #00a9e0;
  }
  
  .blue-tabs .x-tab-bar .x-tab-active {
    background-color: #00a9e0;
  }
  
  .blue-tabs .x-tab-bar .x-tab-active .x-tab-inner {
    color: white;
  }
  
  .blue-tabs .x-tab-bar .x-tab-default .x-tab-inner {
    text-overflow: initial;
    -o-text-overflow: initial;
    overflow: initial;
  }
  
  .blue-tabs .x-tab-bar .x-tab-inner {
    width: 100%;
  }
  
  .blue-tabs .x-tab-bar .x-tab-default .x-tab-icon-el {
    color: white;
  }
    </style>

</head>
<body></body>
</html>